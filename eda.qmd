---
title: "Exploratory Data Analysis (EDA)"
subtitle: "Visual and Statistical Insights from Job Market Data"
author:
  - name: "Anu Sharma, Cindy Guzman, Gavin Boss"
    affiliations:
      - id: bu
        name: Boston University
        city: Boston
        state: MA
date: "2025-10-09"
format:
  html:
    theme: lux
    toc: true
    toc-depth: 2
    number-sections: true
    code-fold: true
    smooth-scroll: true
    code-overflow: wrap
execute:
  echo: true
  eval: true
  warning: false
  message: false
---

### Overview

This Exploratory Data Analysis (EDA) examines job postings from Lightcast to uncover salary trends, experience requirements, remote work dynamics, and skill demand across Business Analytics (BA), Data Science (DS), and Machine Learning (ML) roles.
The analysis prepares the dataset for modeling and provides statistical and visual insights that guide the regression and feature engineering stages of the project.

Specifically, this section covers:

- Data preparation and cleaning – handling duplicates, renaming key columns, converting data types, and computing an Average_Salary variable

- Salary distribution and outliers – visualizing the spread of compensation and identifying high-paying ML and senior roles

- Experience and salary relationships – analyzing how required years of experience influence pay across remote and hybrid work types

- Role-based salary comparison – comparing median salaries for BA, DS, and ML roles

- Remote work trends – exploring how work flexibility impacts compensation

- Top skill frequencies – identifying the most in-demand technical and analytical skills in job descriptions

- Feature correlations – assessing relationships between numeric variables such as salary and experience to inform model selection

Together, these insights establish a clear understanding of labor market patterns and help define which features are most predictive for the upcoming salary regression models.


### Load and Prepare Data
```{python}
# | echo: true
# | eval: true

import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import plotly.figure_factory as ff
import plotly.io as pio
import json
import re
from collections import Counter

pio.templates.default = "plotly_white"
pio.renderers.default = "iframe_connected"

# === Load data from CSV ===
df = pd.read_csv("data/lightcast_job_postings.csv", low_memory=False)
# print(f"Dataset loaded: {len(df):,} rows, {len(df.columns)} columns")

# --- Detect & drop duplicate columns ---
# --- Detect & fully clean duplicate-like columns ---
# Normalize column names: strip whitespace and hidden characters
df.columns = df.columns.str.strip().str.replace(r"\s+", " ", regex=True)

# Collapse exact duplicates after cleanup
before_cols = len(df.columns)
df = df.loc[:, ~df.columns.duplicated()]
after_cols = len(df.columns)

# print(f" Cleaned column names: removed {before_cols - after_cols} duplicate(s).")
# print("Unique columns now:", len(df.columns))

# --- Convert numeric columns safely ---
for col in ["SALARY_FROM", "SALARY_TO", "MIN_YEARS_EXPERIENCE", "MAX_YEARS_EXPERIENCE"]:
    if col in df.columns:
        df[col] = pd.to_numeric(df[col], errors="coerce")

# --- Compute average salary (avoid string concat) ---
if {"SALARY_FROM", "SALARY_TO"}.issubset(df.columns):
    df["Average_Salary"] = df[["SALARY_FROM", "SALARY_TO"]].mean(axis=1, skipna=True)

# --- Clean and rename (safely) ---
rename_map = {
    "REMOTE_TYPE_NAME": "REMOTE_GROUP",
    "STATE_NAME": "STATE",
    "LOT_V6_OCCUPATION_GROUP_NAME": "ROLE_GROUP"
}

# Only rename columns that won't create duplicates
for old, new in rename_map.items():
    if old in df.columns and new not in df.columns:
        df.rename(columns={old: new}, inplace=True)
    elif old in df.columns and new in df.columns:
      # print(f" Skipping rename '{old}' → '{new}' to avoid duplicate column name.")
      pass


# --- Drop invalid rows early ---
if "Average_Salary" in df.columns:
    df = df[df["Average_Salary"].notna() & (df["Average_Salary"] > 0)]

# --- Downsample if dataset is large ---
if len(df) > 5000:
    df = df.sample(5000, random_state=42)

# print(f" Loaded {len(df)} rows safely with {len(df.columns)} unique columns.")
```

### Data Preparation and Cleaning

The dataset used for this analysis was sourced from Lightcast job postings, containing thousands of listings across Business Analytics (BA), Data Science (DS), and Machine Learning (ML) roles.
To ensure data quality and consistency:

Column Normalization: Extra spaces and hidden characters were stripped from column names to avoid mismatches and duplicates.

Duplicate Removal: Identical columns were collapsed to retain only unique fields.

Type Conversion: Numeric columns such as SALARY_FROM, SALARY_TO, MIN_YEARS_EXPERIENCE, and MAX_YEARS_EXPERIENCE were coerced into numeric format, with non-numeric values safely converted to NaN.

Average Salary Calculation: A new feature, Average_Salary, was computed as the mean of the salary range for each posting to simplify analysis.

Column Renaming: Key columns were standardized (REMOTE_TYPE_NAME → REMOTE_GROUP, STATE_NAME → STATE, LOT_V6_OCCUPATION_GROUP_NAME → ROLE_GROUP) for clarity.

Invalid Data Removal: Rows with missing or non-positive salaries were dropped.

Downsampling: For performance, the dataset was randomly reduced to 5,000 representative rows, preserving the statistical diversity of the original population.

This preprocessing established a clean, consistent dataset suitable for visualization and modeling.

```{python}
# Filter out negative or zero salary values before plotting
df_salary = df[df["Average_Salary"] > 0]

fig = px.histogram(
    df,
    x="Average_Salary",
    nbins=40,
    color_discrete_sequence=["#187145"],
    title="Distribution of Average Salaries"
)

fig.update_layout(
    #  Title styling
    title=dict(
        text="<b>Distribution of Average Salaries</b>",
        x=0.5,  # center the title
        xanchor="center",
        font=dict(size=20)
    ),
    
    #  Axis labels
    xaxis_title="<b>Average Salary (USD)</b>",
    yaxis_title="<b>Number of Job Postings</b>",
    
    #  Layout polish
    template="plotly_white",
    width=900,
    height=550,
    bargap=0.05,
    font=dict(size=14),
    margin=dict(l=60, r=40, t=80, b=60)
)

#  Subtle gridlines for readability
fig.update_xaxes(showgrid=True, gridcolor="lightgray", zeroline=False)
fig.update_yaxes(showgrid=True, gridcolor="lightgray", zeroline=False)

fig
```

### Salary Distribution
The salary distribution is right-skewed, indicating that most job postings fall within the $80K–$150K range.
A smaller number of positions extend above $200K, reflecting higher-paying senior and Machine Learning roles.
This pattern suggests that while the majority of opportunities in analytics and data science offer mid-range compensation, specialized expertise and advanced roles drive the upper end of the salary spectrum.

```{python}
# Filter out invalid or missing values
df_exp = df[(df["Average_Salary"] > 0) & (df["MIN_YEARS_EXPERIENCE"] >= 0)].copy()

# Combine '[None]' and 'Not Remote' into 'Onsite'
df_exp["REMOTE_GROUP"] = df_exp["REMOTE_GROUP"].replace({
    None: "Onsite",
    "[None]": "Onsite",
    "Not Remote": "Onsite"
})

#  Create scatter plot with trendlines
fig = px.scatter(
    df_exp,
    x="MIN_YEARS_EXPERIENCE",
    y="Average_Salary",
    color="REMOTE_GROUP",
    trendline="ols",
    title="Salary vs. Minimum Experience by Remote Type",
    color_discrete_sequence=["#187145", "#45A274", "#79C99E"],
    opacity=0.7,
    height=550
)

fig.update_layout(
    title=dict(
        text="<b>Salary vs. Minimum Experience by Remote Type</b>",
        x=0.5,
        xanchor="center",
        font=dict(size=20)
    ),
    xaxis_title="<b>Minimum Years of Experience</b>",
    yaxis_title="<b>Average Salary (USD)</b>",
    template="plotly_white",
    width=900,
    height=550,
    font=dict(size=14),
    legend_title_text="<b>Remote Work Type</b>",
    margin=dict(l=60, r=40, t=80, b=60)
)

#  Final touch: consistent visual polish
fig.update_traces(marker=dict(size=6))
fig.update_xaxes(showgrid=True, gridcolor="lightgray", zeroline=False)
fig.update_yaxes(showgrid=True, gridcolor="lightgray", zeroline=False)

fig
```

### Salary vs Experience
The scatterplot shows a clear positive relationship between experience and salary across all remote work types. As minimum years of experience increase, average salary consistently rises.
Among the three groups, Remote and Hybrid Remote roles generally track above Not Remote positions, suggesting that employers may offer higher compensation for flexible or remote-friendly roles.
This trend highlights how both experience level and work flexibility contribute to earning potential in analytics and data science careers.

```{python}
#  Filter valid salary data
df_roles = df[df["Average_Salary"] > 0].copy()

#  Create the boxplot
fig = px.box(
    df_roles,
    x="ROLE_GROUP",
    y="Average_Salary",
    color="ROLE_GROUP",
    color_discrete_sequence=[
        "#187145", "#45A274", "#79C99E", "#A7D9C9", "#C9EBDD", "#E3F6EE"
    ],
    title="Salary Comparison Across Role Categories",
    points="outliers",   # show only outliers for clarity
    height=550
)

#  Layout polish
fig.update_layout(
    title=dict(
        text="<b>Salary Comparison Across Role Categories</b>",
        x=0.5,
        xanchor="center",
        font=dict(size=20)
    ),
    xaxis_title="<b>Role Group</b>",
    yaxis_title="<b>Average Salary (USD)</b>",
    template="plotly_white",
    width=900,
    height=550,
    font=dict(size=14),
    legend_title_text="<b>ROLE_GROUP</b>",
    margin=dict(l=60, r=40, t=80, b=120)
)

#  Axis & tick styling
fig.update_xaxes(
    tickangle=30,
    tickfont=dict(size=12),
    showgrid=False
)
fig.update_yaxes(showgrid=True, gridcolor="lightgray", zeroline=False)

fig
```

### Role-Based Salary Trends
The boxplot shows clear salary variation across professional role groups.
Network and Systems Engineering roles offer the highest median salaries and the widest overall pay range, indicating both strong earning potential and greater variation in compensation.
Business Intelligence and Data Analysis and Mathematics positions follow, reflecting competitive pay linked to technical and analytical expertise.
Roles such as Business Analysis, Health IT Professionals, and Marketing Specialists sit at the lower end of the salary scale, with tighter interquartile ranges suggesting more standardized pay structures.

Overall, the trend highlights that roles with deeper technical specialization or infrastructure focus command higher compensation, while business-oriented and support analytics positions tend to offer more consistent but lower salary ranges.


```{python}
#  Copy and clean up data
df_remote = df[df["Average_Salary"] > 0].copy()

#  Combine '[None]' and 'Not Remote' into 'Onsite'
df_remote["REMOTE_GROUP"] = df_remote["REMOTE_GROUP"].replace({
    None: "Onsite",
    "[None]": "Onsite",
    "Not Remote": "Onsite"
})

#  Define custom order for clarity
remote_order = ["Onsite", "Hybrid Remote", "Remote"]

#  Build polished boxplot
fig = px.box(
    df_remote,
    x="REMOTE_GROUP",
    y="Average_Salary",
    color="REMOTE_GROUP",
    category_orders={"REMOTE_GROUP": remote_order},
    color_discrete_sequence=["#187145", "#45A274", "#79C99E"],
    title="Salary Distribution by Remote Work Type",
    points="outliers",  # show only outliers
    height=550
)

#  Aesthetic refinements
fig.update_layout(
    title=dict(
        text="<b>Salary Distribution by Remote Work Type</b>",
        x=0.5,
        xanchor="center",
        font=dict(size=20)
    ),
    xaxis_title="<b>Remote Work Type</b>",
    yaxis_title="<b>Average Salary (USD)</b>",
    template="plotly_white",
    width=900,
    height=550,
    font=dict(size=14),
    legend_title_text="<b>Remote Work Type</b>",
    legend=dict(
        orientation="v",
        yanchor="top",
        y=0.98,
        xanchor="right",
        x=1.12,
        font=dict(size=12)
    ),
    margin=dict(l=60, r=120, t=80, b=100)
)

#  Axis polish
fig.update_xaxes(
    tickangle=0,
    showgrid=False,
    tickfont=dict(size=13)
)
fig.update_yaxes(showgrid=True, gridcolor="lightgray", zeroline=False)

fig
```

### Remote Work vs Salary Trends
The salary distribution varies noticeably by remote work type.
Remote roles show the highest median salaries and a slightly wider interquartile range, indicating greater earning potential and variability among remote positions.
Hybrid Remote jobs follow closely, offering competitive pay and a balanced distribution between onsite and remote work structures.
In contrast, Onsite roles have the lowest median salaries and a tighter spread, suggesting more standardized compensation.
Overall, the trend suggests that flexible and fully remote positions command higher pay, reflecting market demand for adaptable, tech-enabled talent.

```{python}
#  Use the detected skill column
skills_column = "COMMON_SKILLS_NAME"  # replace if another had more data

#  Flatten and clean skills
skills_flat = [
    s.strip().replace('"', '')  # remove quotation marks
    for sublist in df[skills_column].dropna().astype(str).str.split(',')
    for s in sublist if s.strip()
]

#  Count top 15 skills
skill_counts = pd.DataFrame(
    Counter(skills_flat).most_common(15),
    columns=["Skill", "Count"]
)

#  Bar chart
fig = px.bar(
    skill_counts,
    x="Skill",
    y="Count",
    title="Top 15 Most Frequent Skills",
    color_discrete_sequence=["#187145"]
)

#  Clean layout
fig.update_layout(
    title=dict(
        text="<b>Top 15 Most Frequent Skills</b>",
        x=0.5,
        xanchor="center",
        font=dict(size=22)
    ),
    xaxis_title="<b>Skill</b>",
    yaxis_title="<b>Number of Job Postings</b>",
    template="plotly_white",
    width=900,
    height=550,
    font=dict(size=14),
    margin=dict(l=60, r=40, t=80, b=120)
)

#  Axis styling
fig.update_xaxes(
    tickangle=35,
    tickfont=dict(size=12),
    showgrid=False,
    tickvals=list(range(len(skill_counts))),
    ticktext=[skill.replace(" (Programming Language)", "") for skill in skill_counts["Skill"]]
)
fig.update_yaxes(showgrid=True, gridcolor="lightgray", zeroline=False)

fig
```

### Top Skills Frequency
The top skills highlight a blend of technical, analytical, and soft-skill competencies valued across data-driven roles.
Communication and Data Analysis appear most frequently, underscoring the importance of translating insights into business impact.
SQL, Python, and Microsoft Excel remain core technical skills, while Project Management, Leadership, and Problem Solving emphasize the need for strategic coordination and cross-functional collaboration.
Overall, this distribution reflects that successful analytics professionals combine technical proficiency with strong interpersonal and organizational skills, aligning with modern employer expectations in business analytics and data science.

```{python}
#  Compute correlation matrix
corr_cols = ["Average_Salary", "MIN_YEARS_EXPERIENCE", "MAX_YEARS_EXPERIENCE"]
corr = df[corr_cols].corr().round(2)

#  Create heatmap
fig = ff.create_annotated_heatmap(
    z=corr.values,
    x=corr.columns.tolist(),
    y=corr.columns.tolist(),
    colorscale="greens",
    showscale=True,
    annotation_text=corr.values,
    font_colors=["black"],
    hoverinfo="none"
)

#  Layout adjustments
fig.update_layout(
    title=dict(
        text="<b>Feature Correlation Matrix</b>",
        x=0.5,
        xanchor="center",
        font=dict(size=20)
    ),
    template="plotly_white",
    width=700,
    height=500,
    margin=dict(l=100, r=100, t=120, b=80), 
    font=dict(size=14)
)

#  Axis polish
fig.update_xaxes(
    side="bottom",
    tickangle=35,
    tickfont=dict(size=12),
    title_standoff=10
)
fig.update_yaxes(
    tickfont=dict(size=12),
    autorange="reversed"
)

fig
```

### Feature Correlation Analysis Heatmap
This correlation analysis evaluates the linear relationships between Average Salary, Minimum Years of Experience, and Maximum Years of Experience.
The results show that salary is moderately correlated with both experience metrics — 0.51 with minimum and 0.58 with maximum years of experience. This indicates that as experience increases, compensation tends to rise, though not perfectly linearly.
The strong correlation (1.0) between minimum and maximum experience suggests these variables are closely tied — employers typically define experience ranges that scale together.

Overall, the heatmap confirms that experience is a meaningful predictor of salary, supporting its inclusion as a key numerical feature in subsequent regression modeling.
